---
layout:     post
title:      "数据库(2)"
subtitle:   "数据库笔记"
date:       2020-09-27
author:     "Shooting"
header-img: "img/DataBase-bg.jpg"
catalog: true
tags:
	- 学习
	- 数据库
---

# 数据库转储

区分redo和undo 的唯一标准：有没有commit，有的话做redo

需要undo的：事务跨转储结束——硬盘损坏

需要redo的：事务**结束于**转储开始后，硬盘损坏前

数据转储：是数据库恢复中采用的基本技术。所谓转储即DBA 定期地将数据库复制到磁带或另一个磁盘上保存起来的过程。当数据库遭到破坏后可以将后备副本重新装入，将数据库恢复到转储时的状态。

静态转储：在系统中无运行事务时进行的转储操作。静态转储简单，但必须等待正运行的用户事务结束才能进行。同样，新的事务必须等待转储结束才能执行。这会降低数据库的可用性。

动态转储：指转储期间允许对数据库进行存取或修改。动态转储可克服静态转储的缺点，它不用等待正在运行的用户事务结束，也不会影响新事务的运行。但是，转储结束时后援副本上的数据并不能保证正确有效。因为转储期间运行的事务可能修改了某些数据，使得后援副本上的数据不是数据库的一致版本。为此，必须把转储期间各事务对数据库的修改活动登记下来，建立日志文件( 109 file ）。这样，后援副本加上日志文件就能得到数据库某一时刻的正确状态。转储还可以分为海量转储和增量转储两种方式。

海量转储：指每次转储全部数据库。

增量转储：指每次只转储上一次转储后更新过的数据。从恢复角度看，使用海量转储得到的后备副本进行恢复一般说来更简单些。但如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效。

日志文件
日志文件的作用：

	1. 日志文件是用来记录事务对数据库的更新操作的文件
	2. 事务故障恢复和系统故障必须使用日志文件
	3. 在动态转储方式中必须建立日志文件，后援副本和日志文件综合起来才能有效的恢复数据库，静态转储方式中，也可以建立日志文件

日志文件主要有两种格式：以记录为单位的日志文件和以数据块为单位的日志文件。登记日志文件时必须遵循两条原则：

	1. 登记的次序严格按并发事务执行的时间次序
	2. 必须先写日志文件，后写数据块。

　　对数据库的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作。有可能在这两个操作之间发生故障，即这两个写操作只完成一个。如果先写了数据库修改，而在运行记录中没有登记这个修改，则以后就无法恢复这个修改了。如果先写日志，但没有修改数据库，按日志恢复数据库时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性。所以为了安全，一定要先写日志文件，即首先把日志记录写到日志文件中，然后写数据库的修改。这就是“先写日志文件”的原则。


<br/>
<br/>



---

# 数据库恢复技术


### 事务的基本概念

事务是恢复和并发控制的基本单位


### 事务结束

- COMMIT：正常结束
- ROLLBACK：异常终止，滚回到开始的状态


### 事务的ACID特性

- 原子性（Atomicity）：事务中的操作要么都做要么都不做，保证一致性
- 一致性（Consistency）：数据库中只包含成功事务提交的结果
- 隔离性（Isolation）：一个事务的执行不被其他事务干扰
- 持续性（Durability）：事务对数据库中数据的改变是永久性的


### 故障的种类与恢复技术（解决ACD）

区分redo和undo 的唯一标准：有没有commit，有的话做redo

需要undo的：事务跨转储结束——硬盘损坏

需要redo的：事务**结束于**转储开始后，硬盘损坏前


### 数据库转储

- 静态转储：在系统中无运行事务时进行的转储操作
- 动态转储：转储期间允许对数据库进行存取或修改
- 海量转储：每次转储全部数据库
- 增量转储：只转储上次转储后更新过的数据


### 日志文件

- 以记录为单位：记录的是操作
- 以数据块为单位：记录的是数据的修改

注意：先写日志文件，后写数据库修改！
![avatar](img/in-post/post-database/故障与恢复.png)
 


### 恢复策略

- 事务故障：由恢复子系统利用日志文件撤消（UNDO）此事务已对数据库进行的修改
- 系统故障：先Undo故障发生时未完成的事务，然后Redo已完成的事务（反过来不行，不能保证隔离性的情况下无法保证正确）
- 介质故障：重装数据库，重做已完成的事务

数据库镜像：预防介质故障，且可用于并发操作


<br/>
<br/>



---

# 并发控制


### 需要解决的问题

- 丢失修改：两个事务同时修改一个数据
- 读脏数据：一个事务修改数据，另一个事务在这个事务结束前读了这个数据，导致读到的数据与数据库中不一致
- 不可重复读：一个事务在运行过程中读两次记录，在两次读之间这个记录被另一个事务修改/插入/删除了


### 解决技术

- 封锁
- 时间戳
- 乐观控制法
- 多版本并发控制


### 封锁

表示事务对数据的控制（占有）

- X锁：排他锁，写锁，只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁
- S锁：共享锁，读锁，事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁


### 封锁协议
![avatar](img/in-post/post-database/封锁协议.png)
 


### 活锁/死锁

- 活锁：排队
- 死锁
	- 预防：一次封锁法、顺序封锁法
	- 诊断：超时法、等待图法
	- 解除：选择一个处理代价最小的事务，将其撤销


### 可串行化调度

可串行化=正确的并发执行=多个事务的执行结果与某次串行执行结果相同

在隔离性效果上达到了三级封锁协议


### 两段锁协议

是可串行化调度的**充分条件**

将事务分为两个阶段：

- 扩展阶段：获得封锁，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁
- 收缩阶段：释放封锁，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁
![avatar](img/in-post/post-database/封锁协议总结.png)
 


### 封锁的粒度

指封锁对象的大小。粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小。粒度越小，并发度较高，但系统开销也就越大。
