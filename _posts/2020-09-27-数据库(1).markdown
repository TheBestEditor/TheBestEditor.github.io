---
layout:     post
title:      "数据库"
subtitle:   "数据库笔记"
date:       2020-09-27
author:     "Shooting"
header-img: "img/DataBase-bg.jpg"
---


# 概论

实体（entity）：数据模型中的数据对象，每个实体都有若干个成员。用长方形表示

关系（relationship）：实体与实体之间的联系。用棱形表示

属性（attribute）：实体具有的特征，分为唯一属性和非唯一属性

主键和外键：[blog.csdn.net/f45056231p/article/details/81070437](https://blog.csdn.net/f45056231p/article/details/81070437)

E-R图：[www.jianshu.com/p/9ff938e3a498](https://www.jianshu.com/p/9ff938e3a498)


</br>
</br>


---

# 数据库模型


### 基本概念

数据，数据库，数据库管理系统，数据库系统（DBS）


### 数据管理技术的产生和发展

- 人工管理阶段
- 文件系统阶段
- 数据库系统阶段


### 数据库系统的特点

- 数据结构化：数据用数据模型描述，无需应用程序定义
- 数据的共享性高，冗余度低且易扩充
- 数据独立性高：物理独立性+逻辑独立性
- 数据有数据库管理系统统一管理和控制
	- 安全性保护
	- 完整性检查：正确性、有效性、相容性
	- 并发控制
	- 数据库恢复


### 数据模型

现实世界->概念模型->逻辑模型->物理模型

数据模型三要素

- 数据结构（静态）
- 数据操作（动态）
- 完整性约束（静态）

三种主要数据库模型：层次、网状、关系

关系数据库的概念
![avatar](img/in-post/post-database/关系数据库.png)
 

- 候选码：关系中某一属性组的值能唯一标识一个元组，而其子集不能
- 超码：候选码的超集
- 全码：所有属性组是这个关系模式的候选码（注意：全是主属性=!全码）
- 主码：选一个候选码作为关系的主码
- 主属性：包含在候选码中的属性
- 非主属性：不包含在候选码中的属性
- 外码：关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外码

ER图转关系模型：1:1的可独立可与任意一端合并；1:n可独立或__与n端合并__；m:n独立


# DBS内部的系统结构

三级模式：外模式<-模式->内模式

两层映像：外模式/模式映像，模式/内模式映像


</br>
</br>

---

# 关系数据结构


## 相关概念

域：是一组具有相同的数据类型的值的集合

笛卡尔积

元组：笛卡尔积中的每一个元素叫做一个n元组（每一行）

分量：笛卡尔积元素中的每一个值（每一个格子）

基数：做笛卡尔积的每一个集合的元组个数（行数）相乘（即最后笛卡尔积结果的行数）

关系：集合做笛卡尔积的**子集**

（关系的）度/目：关系的属性个数（列数）


### 三类关系：

- 基本关系
- 查询表
- 视图表


## 关系模式

关系模式是型（Type），关系是值（Value），关系模式是对关系的描述

定义：R（U，D，DOM，F）

- R：表名
- U：组成该关系的属性名集合（表头）
- D：某表头的数据类型
- DOM：属性向域的映像集合
- F：属性间数据依赖关系的集合

</br>
</br>



---

# 关系操作

查询操作：选择、投影、连接、除、并、交、差、笛卡尔积

数据更新：插入、删除、修改

五种基本操作：选择、投影、并、差、笛卡尔积（能构成其他操作）
![avatar](img/in-post/post-database/运算符号.png)
 

像集：给定一个关系R（X，Z），X和Z为属性组。当t[X]=x时，x在R中的象集为：Zx={t[Z]|t 属于R，t[X]=x}，它表示R中属性组X上值为x的诸元组在Z上分量的集合

笛卡尔积：不同关系中的重名属性用关系名.属性名表示

选择：行角度的运算

投影：列角度的运算，去重

连接：从两个关系的笛卡尔积中选取属性间满足一定条件的元组（行操作）

- θ：比较运算符 
- 等值连接：θ为“＝”的连接运算
- 自然连接：特殊的等值连接，在结果中把重复的列去掉（行+列操作）
- 外连接：把悬浮元组也保存在结果关系中，在其他属性上填空值(Null)
	- 左外连接：只保留左边关系中的悬浮元组
	- 右外连接：只保留右边关系中的悬浮元组

除：给定关系R (X，Y) ，S (Y，Z)，R÷S表示元组在X上分量值x的象集Yx包含S在Y上投影的集合（行+列操作）



</br>
</br>


---

# 关系的完整性

关系的两个不变性：

- **实体完整性（entity integrity）**：关系的**主属性**不能取空值（null）
- **参照完整性（refe rential integrity）**：属性F是关系R的**外码**，与关系S的主码Ks相对应（__R跟S可能相同__）则对于R中每个元组在F上的值必须：
	- 或者取空值（__F的每个属性均为空值__）-> 表示未建立对应关系
	- 或者等于S中某个元组的主码值

**用户定义的完整性（user-defined integrity）**



</br>
</br>


---

# 关系数据理论

好的关系模式应消除：

- 数据冗余
- 更新异常
- 插入异常
- 删除异常

解决方法：分解关系，消除其中不合适的数据依赖


### 数据依赖

是语义的体现

类型

- 函数依赖
- 多值依赖


# 规范化


## 函数依赖

- X→Y：“X函数确定Y ”或“Y函数依赖于X”，X称为这个函数依赖的**决定性因素**
- X←→Y：X→Y，并且Y→X
- X\→Y：Y不函数依赖于X


### 分类

- 平凡/非平凡：X→Y，Y⊆X是平凡的，平凡函数依赖必然成立，一般讨论的都是非平凡
- 完全/部分：X中的所有元素加起来才能决定Y（F）；X中部分元素就能决定Y了（P）
- 传递：X→Y(Y⊈X)，Y↛X，Y→Z，Z⊈Y, 则称Z对X传递函数依赖（注意：如果Y→X, 即X←→Y，则Z直接依赖于X，而不是传递函数依赖）


### 范式

- 1NF：数据原子性（关系模式都是）
- 2NF：去除非主属性对码的部分函数依赖（所有候选码都是单属性必是2NF）
- 3NF：去除非主属性对码的传递函数依赖（所有属性都是主属性必是3NF）
- BCNF：去除所有属性对码的部分和传递函数依赖（全码关系必是BCNF）

达到BCNF则实现了**在函数依赖范畴内的**彻底的分离，消除了插入和删除的异常


## 多值依赖


### 定义

- 设R(U)是属性集U上的一个关系模式。X,Y,Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)值，有一**组**Y的值，这组值仅仅决定于x值而与z值无关（注意是一组）
- 平凡/非平凡的多值依赖：X→→Y，Z为空/不为空


### 性质

- 对称性：若X→→Y，则X→→Z，其中Z＝U－X－Y
- 传递性：若X→→Y，Y→→Z， 则X→→Z -Y
- 函数依赖是多值依赖的特殊情况，即若X→Y，则X→→Y
- 若X→→Y，X→→Z，则X→→YZ
- 若X→→Y，X→→Z，则X→→Y∩Z
- 若X→→Y，X→→Z，则X→→Y-Z，X→→Z -Y

4NF：对于R的每个非平凡多值依赖X→→Y（Y ⊈ X），X都含有码，消除了非平凡且非函数依赖的多值依赖
